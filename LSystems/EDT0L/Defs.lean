import Mathlib.Computability.Language
import Mathlib.Computability.DFA
import Mathlib.Data.List.Basic
import Mathlib.Logic.Equiv.Basic
import Mathlib.Logic.Relation

/-!
# EDT0L Grammars

An EDT0L grammar consists of the following data:
 * a finite alphabet of terminal letters `T`;
 * a finite alphabet of nonterminal letters `N`;
 * an initial nonterminal letter; and
 * a finite number of maps of the form `N â†’ List (Symbol T N)` which we refer to as tables.
Notice that `Symbol T N` is a type, provided by Mathlib, which corresponds to a disjoint union
of the types `T` and `N`.

To simplify proofs in this project, we index the tables of the grammar using a finite type `H`.

## Applying tables

Suppose we are given some word `w : List (Symbol T N)`, then we may apply a table of the form
`Ï„ : N â†’ List (Symbol T N)` by replacing each nonterminal in `w` with the corresponding word
given by `Ï„`, and leaving all the terminal letters along.

Let `E` be an EDT0L grammar. Then, a word `w : List T` is then accepted by the grammar if the word
`w.map Symbol.terminal` can be reached from the initial word `[Symbol.nonterminal E.intial]`
by applying a finite sequence of tables. The set of all such words is known as an EDT0L language.
-/

/-- EDT0L grammar with terminals `T`, nonterminals `N`, and tables `H`. -/
@[ext]
structure EDT0LGrammar (T N H : Type*) [Fintype N] [Fintype H] where
  /-- Initial nonterminal of the grammar -/
  initial : N
  /-- The finite set of tables, as indexed by `H`. -/
  tables : H â†’ N â†’ List (Symbol T N) 

namespace EDT0LGrammar
variable {T N H : Type*} [Fintype H] [Fintype N]
variable (E : EDT0LGrammar T N H)

/-- Rewrites a symbol with respect to a given table. -/
def RewriteSymbol (Ï„ : H) : Symbol T N â†’ List (Symbol T N)
  | .terminal t => [ .terminal t ]
  | .nonterminal n => E.tables Ï„ n

/-- Applies a given table to the given word. -/
def RewriteWord (Ï„ : H) (w : List (Symbol T N)) : List (Symbol T N) :=
  w.flatMap (E.RewriteSymbol Ï„)

/-- A relation which holds if there exists a table which rewrites the word
`source` to the word `target`. -/
def Rewrites (source target : List (Symbol T N)) : Prop :=
  âˆƒ Ï„ : H, E.RewriteWord Ï„ source = target

/-- The reflexive transitive closure of `EDT0LGrammar.Rewrites`. -/
def Derives : List (Symbol T N) â†’ List (Symbol T N) â†’ Prop :=
  Relation.ReflTransGen E.Rewrites

/-- The given word can be derived from the inital word. -/
def Generates (w : List (Symbol T N)) : Prop :=
  E.Derives [Symbol.nonterminal E.initial] w

/-- The language produced by the EDT0L grammar -/
def language : Language T :=
  { w : List T | E.Generates (w.map Symbol.terminal) }

end EDT0LGrammar

/-- The language is EDT0L.

Notice that this definition requries that the language is generated by an EDT0L language
where the set of nonterminals and terminals are of the form `Fin n` and `Fin m`, respectively,
for some `n m : â„•`. Our main goal in this file is to show that we can assume without loss of
generality that any given EDT0L grammar is of this form. We prove this fact in the theorem
`edt0l_grammars_generate_edt0l_languages`, at the end of this file. -/
def Language.IsEDT0L {T : Type*} (L : Language T) : Prop :=
  âˆƒ n m : â„•, âˆƒ E : EDT0LGrammar T (Fin n) (Fin m), E.language = L

namespace EDT0LGrammar
variable {T N H : Type*} [Fintype H] [Fintype N]

-- now let's prove some very basic lemmas for `RewriteSymbol`

namespace RewriteSymbol
variable (E : EDT0LGrammar T N H) (Ï„ : H)

@[simp]
lemma terminal (a : T) :
    E.RewriteSymbol Ï„ (.terminal a) = [.terminal a] := by
  unfold RewriteSymbol
  simp only

@[simp]
lemma nonterminal (n : N) :
    E.RewriteSymbol Ï„ (.nonterminal n) = E.tables Ï„ n := by
  unfold RewriteSymbol
  simp only

end RewriteSymbol

-- let's now move on to words

namespace RewriteWord
variable (E : EDT0LGrammar T N H) (Ï„ : H)

@[simp]
lemma nil : E.RewriteWord Ï„ [] = [] := rfl

@[simp]
lemma cons {a : Symbol T N} {as : List (Symbol T N)} :
    E.RewriteWord Ï„ (a::as) = (E.RewriteSymbol Ï„ a) ++ (E.RewriteWord Ï„ as) := rfl

@[simp]
lemma append {a b : List (Symbol T N)} :
    E.RewriteWord Ï„ (a ++ b) = (E.RewriteWord Ï„ a) ++ (E.RewriteWord Ï„ b) := List.flatMap_append

@[simp]
lemma single {a : Symbol T N} :
    E.RewriteWord Ï„ [a] = E.RewriteSymbol Ï„ a := by
  simp only [cons, nil, List.append_nil]

@[simp]
lemma terminal_word {w : List T} :
    E.RewriteWord Ï„ (w.map .terminal) = (w.map .terminal) := by
  induction w with
  | nil => simp only [List.map_nil, nil]
  | cons a as ih =>
    simp only [List.map_cons]
    simp only [cons, RewriteSymbol.terminal]
    simp only [List.cons_append, List.nil_append]
    rw [ih]

end RewriteWord

-- rewrites definition

namespace Rewrites
variable (E : EDT0LGrammar T N H) (Ï„ : H)

lemma nil {w : List (Symbol T N)} : E.Rewrites [] w â†’ w = [] := by
  intro âŸ¨Ï„,hâŸ©
  simp only [RewriteWord.nil, List.nil_eq] at h
  exact h

lemma terminal_word {w : List T} {w' : List (Symbol T N)} (h : E.Rewrites (w.map .terminal) w') :
    w' = (w.map .terminal) := by
  replace âŸ¨Ï„,hâŸ© := h
  simp only [RewriteWord.terminal_word] at h
  subst h
  rfl

end Rewrites

-- The following namespace contains proofs that Derives is reflexive and transitive
-- and the corresponding type class instanciations. These type classes are needed if
-- you want to use the `calc` tactic.

namespace Derives
section lemmas_for_derives
variable {a b c : List (Symbol T N)}
variable {E : EDT0LGrammar T N H}

lemma trans (hâ‚ : E.Derives a b) (hâ‚‚ : E.Derives b c) :
    E.Derives a c := Relation.ReflTransGen.trans hâ‚ hâ‚‚

lemma single (h : E.Rewrites a b) :
    E.Derives a b := Relation.ReflTransGen.single h

lemma head (hâ‚ : E.Rewrites a b) (hâ‚‚ : E.Derives b c) :
    E.Derives a c := Relation.ReflTransGen.head hâ‚ hâ‚‚

lemma tail (hâ‚ : E.Derives a b) (hâ‚‚ : E.Rewrites b c) :
    E.Derives a c := Relation.ReflTransGen.tail hâ‚ hâ‚‚

lemma refl : E.Derives a a := Relation.ReflTransGen.refl

end lemmas_for_derives

section class_instances_for_derives
variable (E : EDT0LGrammar T N H)

instance : Trans E.Derives E.Derives E.Derives where
  trans hâ‚ hâ‚‚ := Derives.trans hâ‚ hâ‚‚

instance : Trans E.Derives E.Rewrites E.Derives where
  trans hâ‚ hâ‚‚ := Derives.tail hâ‚ hâ‚‚

instance : Trans E.Rewrites E.Derives E.Derives where
  trans hâ‚ hâ‚‚ := Derives.head hâ‚ hâ‚‚

instance : Trans E.Rewrites E.Rewrites E.Derives where
  trans hâ‚ hâ‚‚ := Derives.tail (Derives.single hâ‚) hâ‚‚

instance : IsTrans (List (Symbol T N)) E.Derives where
  trans _ := fun _ _ hxy hyz â†¦ Derives.trans hxy hyz

instance : IsRefl (List (Symbol T N)) E.Derives where
  refl _ := Derives.refl

instance : IsPreorder (List (Symbol T N)) E.Derives where
  trans _ := fun _ _ hxy hyz â†¦ Derives.trans hxy hyz
  refl _ := Derives.refl

end class_instances_for_derives
end Derives

-- some additional lemmas about derives

namespace Derives
variable (E : EDT0LGrammar T N H)

lemma nil {w : List (Symbol T N)} : E.Derives [] w â†’ w = [] := by
  intro h
  unfold Derives at h
  induction h with
  | refl => rfl
  | tail h_a hab ha =>
    rename_i a b
    subst ha
    exact Rewrites.nil E hab

lemma terminal_word {w : List T} {w' : List (Symbol T N)} (h : E.Rewrites (w.map .terminal) w') :
    w' = (w.map .terminal) := by
  replace âŸ¨Ï„,hâŸ© := h
  simp only [RewriteWord.terminal_word] at h
  subst h
  rfl

end Derives

-- generates

section Generates
variable (E : EDT0LGrammar T N H)
lemma generates_initial : E.Generates [.nonterminal E.initial] := Relation.ReflTransGen.refl
end Generates

end EDT0LGrammar

-- now we get to the main part of this file where we define
-- equivalent EDT0L grammars

namespace EDT0LGrammar

/-- Defines an equivalent EDT0L grammar.

This structure holds the data needed to construct an EDT0L grammar which can be used in the
proof of `edt0l_grammars_generate_edt0l_languages`. We provide this construction as its own
structure as this construction is to be reused when defining EDT0L grammars with finite index -/
structure EquivData {T N H N' H' : Type*} [Fintype N] [Fintype H] [Fintype N'] [Fintype H'] where
  /-- The grammar for which we want to find an equivalent grammar. -/
  E : EDT0LGrammar T N H
  /-- An equivalence relation between nonterminals. -/
  equivN : N â‰ƒ N'
  /-- An equivalence relation between tables. -/
  equivH : H â‰ƒ H'

namespace EquivData
variable {T N N H N' H' : Type*} [Fintype N] [Fintype H] [Fintype N'] [Fintype H'] 
variable (ğ“– : @EquivData T N H N' H' _ _ _ _)

/-- An equivalence relation between symbols of terminals and nonterminals.

This equivalence relation is constructed from the equivalence relation between
nonterminals, as stored in the `EquivData` structure. -/
def equiv_symbol : (Symbol T N) â‰ƒ (Symbol T N') where
  toFun := fun s â†¦ match s with
    | .terminal t => .terminal t
    | .nonterminal n => .nonterminal (ğ“–.equivN n)
  invFun := fun s â†¦ match s with
    | .terminal t => .terminal t
    | .nonterminal n => .nonterminal (ğ“–.equivN.symm n)
  left_inv := by
    unfold Function.LeftInverse
    intro x
    cases x
    Â· rfl
    Â· simp_all only [Equiv.symm_apply_apply]
  right_inv := by
    unfold Function.RightInverse
    unfold Function.LeftInverse
    intro x
    cases x
    Â· rfl
    Â· simp_all only [Equiv.apply_symm_apply]

/-- An equivalence relation between words.

This equivalence relation is constructed from the equivalence relation between
nonterminals, as stored in the `EquivData` structure. -/
def equiv_word : List (Symbol T N) â‰ƒ List (Symbol T N') where
  toFun := List.map ğ“–.equiv_symbol
  invFun := List.map ğ“–.equiv_symbol.symm
  left_inv := by
    unfold Function.LeftInverse
    intro x
    simp_all only [
      List.map_map,
      Equiv.symm_comp_self,
      List.map_id_fun,
      id_eq]
  right_inv := by
    unfold Function.RightInverse
    unfold Function.LeftInverse
    intro x
    simp_all only [
      List.map_map,
      Equiv.self_comp_symm,
      List.map_id_fun,
      id_eq]

/-- Constructs an EDT0L grammar equivalent to the one store in `EquivData`. -/
def grammar : EDT0LGrammar T N' H' where
  initial := ğ“–.equivN ğ“–.E.initial
  tables := fun h n â†¦ ğ“–.equiv_word (ğ“–.E.tables (ğ“–.equivH.symm h) (ğ“–.equivN.symm n))

lemma equiv_symbol_terminal (a : T) : ğ“–.equiv_symbol (.terminal a) = .terminal a := by
  unfold EquivData.equiv_symbol
  simp only [Equiv.coe_fn_mk]

lemma equiv_symbol_nonterminal (n : N) :
    ğ“–.equiv_symbol (.nonterminal n) = .nonterminal (ğ“–.equivN n) := by
  unfold EquivData.equiv_symbol
  simp only [Equiv.coe_fn_mk]

@[simp high]
lemma equiv_word_nil : ğ“–.equiv_word [] = [] := rfl

@[simp high]
lemma equiv_word_singleton (a : Symbol T N) : ğ“–.equiv_word [a] = [ğ“–.equiv_symbol a] := by
  unfold equiv_word
  simp only [Equiv.coe_fn_mk, List.map_cons, List.map_nil]

@[simp high]
lemma equiv_word_cons {a : Symbol T N} {as : List (Symbol T N)} :
    ğ“–.equiv_word (a::as) = (ğ“–.equiv_symbol a) :: (ğ“–.equiv_word as) := by
  rw [equiv_word]
  simp only [Equiv.coe_fn_mk, List.map_cons]

@[simp high]
lemma equiv_word_append {a b : List (Symbol T N)} :
    ğ“–.equiv_word (a ++ b) = (ğ“–.equiv_word a) ++ (ğ“–.equiv_word b) := by
  induction a with
  | nil => simp only [List.nil_append, equiv_word_nil]
  | cons a as ih =>
    simp only [List.cons_append]
    simp only [equiv_word_cons]
    simp only [List.cons_append]
    rw [â† ih]

@[simp high]
lemma equiv_word_terminal (w : List T) :
    ğ“–.equiv_word (w.map .terminal) = w.map .terminal := by
  induction w with
  | nil =>
    unfold equiv_word
    simp only [List.map_nil, Equiv.coe_fn_mk]
  | cons a as ih =>
    simp only [List.map_cons, equiv_word_cons]
    rw [â† ih]
    simp only [List.cons.injEq, and_true]
    rfl

def symm := EquivData.mk ğ“–.grammar ğ“–.equivN.symm ğ“–.equivH.symm

@[simp]
lemma symm_equiv_symbol : ğ“–.symm.equiv_symbol = ğ“–.equiv_symbol.symm := by
  unfold symm
  unfold equiv_symbol
  rfl

@[simp]
lemma symm_equiv_word : ğ“–.symm.equiv_word = ğ“–.equiv_word.symm := by
  unfold symm
  unfold equiv_word
  rfl

@[simp high]
lemma equiv_word_nil' : ğ“–.equiv_word.symm [] = [] := rfl

@[simp high]
lemma equiv_word_singleton' (a : Symbol T N') :
    ğ“–.equiv_word.symm [a] = [ğ“–.equiv_symbol.symm a] := by
  simp only [â† symm_equiv_word]
  simp only [equiv_word_singleton]
  rfl

@[simp high]
lemma equiv_word_cons' {a : Symbol T N'} {as : List (Symbol T N')} :
    ğ“–.equiv_word.symm (a::as) = (ğ“–.equiv_symbol.symm a) :: (ğ“–.equiv_word.symm as) := by
  rw [equiv_word]
  simp only [Equiv.coe_fn_symm_mk, List.map_cons]

@[simp high]
lemma equiv_word_append' {a b : List (Symbol T N')} :
    ğ“–.equiv_word.symm (a ++ b) = (ğ“–.equiv_word.symm a) ++ (ğ“–.equiv_word.symm b) := by
  induction a with
  | nil => simp only [List.nil_append, equiv_word_nil']
  | cons a as ih =>
    simp only [List.cons_append]
    simp only [equiv_word_cons']
    simp only [List.cons_append]
    rw [â† ih]

@[simp high]
lemma equiv_word_terminal' (w : List T) :
    ğ“–.equiv_word.symm (w.map .terminal) = w.map .terminal := by
  induction w with
  | nil =>
    unfold equiv_word
    simp only [List.map_nil, Equiv.coe_fn_symm_mk]
  | cons a as ih =>
    simp only [List.map_cons, equiv_word_cons']
    rw [â† ih]
    simp only [List.cons.injEq, and_true]
    rfl

@[simp]
lemma symm_grammar : ğ“–.symm.grammar = ğ“–.E := by
  ext1
  Â· unfold EquivData.symm
    unfold EquivData.grammar
    simp only [Equiv.symm_apply_apply]
  Â· unfold EquivData.symm
    unfold EquivData.grammar
    simp only [Equiv.symm_symm, Equiv.symm_apply_apply]
    funext h n
    change ğ“–.symm.equiv_word _ = _
    simp only [symm_equiv_word, Equiv.symm_apply_apply]

@[simp]
lemma grammar_rewrite_symbol_iff (Ï„ : H') (s : Symbol T N') :
    ğ“–.grammar.RewriteSymbol Ï„ s
    = ğ“–.equiv_word (
        ğ“–.E.RewriteSymbol
          (ğ“–.equivH.symm Ï„)
          (ğ“–.equiv_symbol.symm s)) := by
  --
  unfold EDT0LGrammar.RewriteSymbol
  split <;> rfl

lemma grammar_rewrite_word_iff (Ï„ : H') (w : List (Symbol T N')) :
    ğ“–.grammar.RewriteWord Ï„ w
    = ğ“–.equiv_word (ğ“–.E.RewriteWord (ğ“–.equivH.symm Ï„) (ğ“–.equiv_word.symm w)) := by
  --
  unfold EDT0LGrammar.RewriteWord
  induction w with
  | nil =>
    simp only [List.flatMap_nil, List.nil_eq]
    rfl
  | cons a as ih =>
    conv =>
      right ; arg 2 ; arg 2
      simp only [â† symm_equiv_word, equiv_word_cons, symm_equiv_word]
    simp only [List.flatMap_cons]
    conv =>
      right
      simp only [â† symm_equiv_word, equiv_word_append, symm_equiv_word]
    rw [ih]
    simp only [grammar_rewrite_symbol_iff, equiv_word_cons', List.flatMap_cons, equiv_word_append]

lemma grammar_rewrites_iff (u v : List (Symbol T N')) :
    ğ“–.grammar.Rewrites u v â†” ğ“–.E.Rewrites (ğ“–.equiv_word.symm u) (ğ“–.equiv_word.symm v) := by
  --
  constructor
  Â· unfold EDT0LGrammar.Rewrites
    intro h
    have âŸ¨Ï„, h'âŸ© := h
    use (ğ“–.equivH.symm Ï„)
    rw [grammar_rewrite_word_iff] at h'
    rw [â† h']
    simp only [Equiv.symm_apply_apply]
  Â· unfold EDT0LGrammar.Rewrites
    intro h
    have âŸ¨Ï„, h'âŸ© := h
    use (ğ“–.equivH Ï„)
    rw [grammar_rewrite_word_iff]
    conv =>
      arg 1 ; arg 2 ; arg 2
      simp only [Equiv.invFun_as_coe, Equiv.toFun_as_coe, Equiv.symm_apply_apply]
    rw [h']
    simp only [Equiv.apply_symm_apply]

lemma grammar_derives_iff_mp (u v : List (Symbol T N')) :
    ğ“–.grammar.Derives u v â†’ ğ“–.E.Derives (ğ“–.equiv_word.symm u) (ğ“–.equiv_word.symm v) := by
  --
  unfold EDT0LGrammar.Derives
  intro h
  induction h with
  | refl =>
    rw [Relation.reflTransGen_iff_eq_or_transGen]
    left
    rfl
  | tail ihâ‚ ihâ‚‚ ihâ‚ƒ =>
    rename_i a b
    replace ihâ‚‚ := (grammar_rewrites_iff ğ“– a b).mp ihâ‚‚
    exact Relation.ReflTransGen.tail ihâ‚ƒ ihâ‚‚

lemma grammar_derives_iff_mpr (u v : List (Symbol T N')) :
    ğ“–.E.Derives (ğ“–.equiv_word.symm u) (ğ“–.equiv_word.symm v) â†’ ğ“–.grammar.Derives u v := by
  --
  simp only [â† symm_grammar]
  intro h
  have hh := grammar_derives_iff_mp
            (EquivData.mk (ğ“–.grammar) (ğ“–.equivN.symm) (ğ“–.equivH.symm))
            (ğ“–.equiv_word.symm u) (ğ“–.equiv_word.symm v)
            h
  conv at hh =>
    arg 2
    change ğ“–.equiv_word _
    simp only [Equiv.invFun_as_coe, Equiv.toFun_as_coe, Equiv.apply_symm_apply]
  conv at hh =>
    arg 3
    change ğ“–.equiv_word _
    simp only [Equiv.invFun_as_coe, Equiv.toFun_as_coe, Equiv.apply_symm_apply]
  exact hh

lemma grammar_derives_iff (u v : List (Symbol T N')) :
    ğ“–.grammar.Derives u v â†” ğ“–.E.Derives (ğ“–.equiv_word.symm u) (ğ“–.equiv_word.symm v) := by
  constructor
  Â· exact grammar_derives_iff_mp _ _ _
  Â· exact grammar_derives_iff_mpr _ _ _

lemma grammar_derives_iff' (u v : List (Symbol T N)) :
    ğ“–.E.Derives u v â†” ğ“–.grammar.Derives (ğ“–.equiv_word u) (ğ“–.equiv_word v) := by
  simp only [â† symm_grammar]
  exact grammar_derives_iff _ _ _

lemma grammar_generates_iff (w : List (Symbol T N)) :
    ğ“–.E.Generates w â†” ğ“–.grammar.Generates (ğ“–.equiv_word w) := grammar_derives_iff' _ _ _

lemma grammar_language_iff (w : List T) :
    ğ“–.E.Generates (List.map .terminal w)
    â†” ğ“–.grammar.Generates (List.map .terminal w) := by
  conv =>
    rhs; arg 2
    rw [â† equiv_word_terminal ğ“–]
  exact grammar_generates_iff _ _

lemma equiv_has_same_language :
    ğ“–.E.language = ğ“–.grammar.language := by
  --
  unfold EDT0LGrammar.language
  simp only [grammar_language_iff]

end EquivData

lemma fin_nonterminals_and_tables {T N H : Type*} [Fintype N] [Fintype H]
  (E : EDT0LGrammar T N H) :
    âˆƒ E' : EDT0LGrammar T (Fin (Fintype.card N)) (Fin (Fintype.card H)),
    E'.language = E.language := by 
  --
  rename_i finN finH
  have isoN := finN.equivFin
  have isoH := finH.equivFin
  let E' := EquivData.mk E isoN isoH
  use E'.grammar
  conv =>
    rhs
    change E'.E.language
  apply Eq.symm
  exact EquivData.equiv_has_same_language _

theorem edt0l_grammars_generate_edt0l_languages {T N H : Type*} [Fintype N] [Fintype H]
  (E : EDT0LGrammar T N H) :
    E.language.IsEDT0L := by
  --
  have âŸ¨E', hâŸ© := fin_nonterminals_and_tables E
  unfold Language.IsEDT0L
  use Fintype.card N, Fintype.card H, E'

end EDT0LGrammar
